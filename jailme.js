var util = require('util');
var vm = require('vm');
require('./cycle');

process.on('uncaughtException', (err) => {
    util.log('Uncaught Exception!!!');
    util.log(err.stack.toString());
});

util.log("mailware-jail, a malware sandbox ver. 0.8");
util.log("------------------------");

// commandline overwrites config.json values
var argv = require('minimist')(process.argv.slice(2));
var _exit = false;

if (argv.h || argv.help) {
    util.log("Usage: node jailme.js  [[-e file1] [-e file2] .. ] [-c ./config.json] \\");
    util.log("\t\t[-o ofile] [-b id] \\");
    util.log("\t\t[-s odir] [--down=y] [malware1 [malware2] .. ]");
    util.log("\t-c config .. use alternative config file, preceed with ./");
    util.log("\t-e ifile ... js that simulates specific environment");
    util.log("\t-o ofile ... name of the file where sandbox shall be dumped at the end");
    util.log("\t-s odir  ... output directory for generated files (malware payload)");
    util.log("\t-b id    ... browser type, use -b list for possible values");
    util.log("\t--down=y ... use http request to download malware components automatically");
    util.log("\tmalware  ... js with the malware code");
    util.log("If no arguments are specified the default values are taken from config.json");
    _exit = true;
}

var config_name = "./config.json";

if (typeof argv.c === 'string') {
    config_name = argv.c
}

var config = require(config_name);

if (typeof argv.b === 'string') {
    if (argv.b === 'list') {
        var a = require('./env/agents.js')._agents;
        util.log("Possible -b values:", Object.keys(a));
        _exit = true;
    } else {
        config.browser_type = argv.b
    }
}
if (_exit)
    return;

function parse_argv_array(a, b) {
    if (a) {
        if (Array.isArray(a) && a.length > 0)
            return a;
        else if (typeof a === 'string')
            return [a];
        else if (typeof a === 'boolean')
            return [];
    }
    return b;
}
config.sandbox_sequence = parse_argv_array(argv.e, config.sandbox_sequence);
util.log("Sandbox environment sequence: " + config.sandbox_sequence);

config.malware_files = parse_argv_array(argv._, config.malware_files);
util.log("Malware files: " + config.malware_files);

if (typeof argv.o === 'string')
    config.context_dump_after = argv.o
util.log("Output file for sandbox dump: " + config.context_dump_after);
if (typeof argv.s === 'string')
    config.save_files = argv.s
util.log("Output directory for generated files: " + config.save_files);
//if (process.platform === "win32") {
//    var rl = require("readline").createInterface({
//        input: process.stdin,
//        output: process.stdout
//    });
//
//    rl.on("SIGINT", function() {
//        console.log("here");
//        process.emit("SIGINT");
//    });
//}
//
//process.on("SIGINT", function() {
//    //graceful shutdown
//    console.log("here");
//    process.exit();
//});

var sandbox = {};

var _dont_log = false;

function mylog() {
    //if (arguments[0].startsWith("function"))
    //    debugger;
    if (_dont_log)
        return;
    util.log.apply(util, arguments);
}


sandbox.id = 1;
sandbox.util_log = mylog
sandbox._iconv = require("iconv-lite");
sandbox._XMLHttpRequest = require("./XMLHttpRequest").XMLHttpRequest;
if (argv.down)
    sandbox._download = true;
//require('http');
sandbox._browser_type = config.browser_type;
sandbox._date = Date;
sandbox.require = require;
sandbox._setTimeout = setTimeout;
sandbox._clearTimeout = clearTimeout;
sandbox._setInterval = setInterval;
sandbox._clearInterval = clearInterval;
sandbox._decodeHTML = require("entities").decodeHTML;
sandbox._inspect = util.inspect;
sandbox._data = {}
sandbox._api = {
    'Array' : Array,
    'Boolean' : Boolean,
    'Date' : Date,
    'Error' : Error,
    'Math' : Math,
    'Number' : Number,
    'Object' : Object,
    'RegExp' : RegExp,
    'String' : String,
    'Node' : {},
    'Element' : undefined,
    'HTMLElement' : undefined,
    'JSON' : JSON,
    'Function' : Function
}

fs = require('fs');

var ctx = vm.createContext(sandbox);
var i, fc;

function run_in_ctx(files, _no_log = false) {
    try {
        for (i = 0; i < files.length; i++) {
            util.log(" => Executing: " + files[i]);
            fc = fs.readFileSync(files[i], 'utf8');
            _dont_log = _no_log;
            vm.runInContext(fc, ctx, {
                filename: files[i]
            });
            _dont_log = false;
        }
    } catch (err) {
        _dont_log = false;
        util.log("Exception occured: " +typeof err + " " + util.inspect(err));
        //if (typeof err.stack !== 'undefined')
        //    util.log("Stack: " + err.stack);
        return false;
    } finally {
        _dont_log = false;
    }
    return true;
}

util.log("==> Preparing Sandbox environment.");
if (!run_in_ctx(config.sandbox_sequence /*, true*/)) return;

//process.on('SIGINT', function () {
//    util.log('Ctrl-C...');
//    process.exit(2);
//});

// Run the malware
util.log("==> Executing malware file(s). =========================================");
run_in_ctx(config.malware_files);

exiting = false;

process.on('beforeExit', (code) => {
    if (exiting)
        return;
    exiting = true;
    util.log("==> Cleaning up sandbox.");
    sandbox.id = 1;
    // sandbox.util_log = undefined;
    sandbox._iconv = undefined;
    sandbox._XMLHttpRequest = undefined;
    sandbox._browser_type = config.browser_type;
    sandbox._date = undefined;
    sandbox.require = undefined;
    sandbox._decodeHTML = undefined;

    util.log("==> Script execution finished, dumping sandbox environment to a file.");

    var out = util.inspect(sandbox);
    out = JSON.stringify(JSON.decycle(sandbox), function(key, value) {
        // convert functions to string
        if (typeof value === 'function') {
            return value.toString();
        }
        return value;
    }, 4);

    fs.writeFile(config.context_dump_after, out, function(err) {
        if (err) {
            return util.log(err);
        }
        util.log("The sandbox context has been  saved to: " + config.context_dump_after);
    });

    var name, p, fname;
    p = sandbox._wscript_saved_files;
    for (var key in p) {
        if (p.hasOwnProperty(key)) {
            name = key.replace(/\/|\\|%/gi, "_");
            fname = config.save_files + name;
            util.log("Saving: " + fname);
            fs.writeFile(fname, p[key], function(err) {
                if (err) {
                    return util.log(err);
                }
                util.log("Generated file saved");
            });
        }
    }
})
